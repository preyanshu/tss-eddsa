/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface SerializablePoint {
  bytes: Array<number>;
}
export interface SerializableScalar {
  bytes: Array<number>;
}
export interface SerializableBigInt {
  bytes: Array<number>;
}
export interface SerializableSharedKeys {
  y: SerializablePoint;
  xI: SerializableScalar;
  prefix: SerializableScalar;
}
export interface SerializableEphemeralSharedKeys {
  r: SerializablePoint;
  rI: SerializableScalar;
}
export interface SerializableSignature {
  r: SerializablePoint;
  s: SerializableScalar;
}
export interface SerializableVerifiableSs {
  threshold: number;
  shareCount: number;
  commitments: Array<SerializablePoint>;
}
export interface SerializableSecretShares {
  shares: Array<SerializableScalar>;
}
export interface SerializableLocalSig {
  gammaI: SerializableScalar;
  k: SerializableScalar;
}
export declare namespace threshold_sig {
  /** Create keys for a party (Phase 1) */
  export function phase1Create(partyIndex: number): string;
  /** Create keys from a private key (Phase 1) */
  export function phase1CreateFromPrivateKey(
    partyIndex: number,
    secret: Array<number>,
  ): string;
  /** Get public key for a keys instance */
  export function getPublicKey(keyId: string): SerializablePoint;
  /** Phase 1 broadcast - returns commitment and blind factor */
  export function phase1Broadcast(keyId: string): any;
  /** Phase 1 verify commitments and Phase 2 distribute shares */
  export function phase1VerifyComPhase2Distribute(
    keyId: string,
    threshold: number,
    shareCount: number,
    blindFactors: Array<SerializableBigInt>,
    publicKeys: Array<SerializablePoint>,
    commitments: Array<SerializableBigInt>,
    parties: Array<number>,
  ): any;
  /** Phase 2 verify VSS and construct keypair */
  export function phase2VerifyVssConstructKeypair(
    keyId: string,
    threshold: number,
    shareCount: number,
    publicKeys: Array<SerializablePoint>,
    secretShares: Array<SerializableScalar>,
    vssSchemes: Array<SerializableVerifiableSs>,
    index: number,
  ): SerializableSharedKeys;
  /** Create ephemeral key from deterministic secret */
  export function ephemeralKeyCreate(
    keyId: string,
    message: Array<number>,
    index: number,
  ): string;
  /** Get ephemeral R point */
  export function getEphemeralR(ephKeyId: string): SerializablePoint;
  /** Ephemeral Phase 1 broadcast */
  export function ephemeralPhase1Broadcast(ephKeyId: string): any;
  /** Ephemeral Phase 1 verify and Phase 2 distribute */
  export function ephemeralPhase1VerifyComPhase2Distribute(
    ephKeyId: string,
    threshold: number,
    shareCount: number,
    blindFactors: Array<SerializableBigInt>,
    rPoints: Array<SerializablePoint>,
    commitments: Array<SerializableBigInt>,
    parties: Array<number>,
  ): any;
  /** Ephemeral Phase 2 verify and construct keypair */
  export function ephemeralPhase2VerifyVssConstructKeypair(
    ephKeyId: string,
    threshold: number,
    shareCount: number,
    rPoints: Array<SerializablePoint>,
    secretShares: Array<SerializableScalar>,
    vssSchemes: Array<SerializableVerifiableSs>,
    index: number,
  ): SerializableEphemeralSharedKeys;
  /** Compute local signature */
  export function computeLocalSig(
    message: Array<number>,
    ephemeralSharedKeys: SerializableEphemeralSharedKeys,
    sharedKeys: SerializableSharedKeys,
  ): SerializableLocalSig;
  /** Verify local signatures */
  export function verifyLocalSigs(
    localSigs: Array<SerializableLocalSig>,
    partiesIndex: Array<number>,
    vssPrivateKeys: Array<SerializableVerifiableSs>,
    vssEphemeralKeys: Array<SerializableVerifiableSs>,
  ): SerializableVerifiableSs;
  /** Generate final signature */
  export function generateSignature(
    vssSumLocalSigs: SerializableVerifiableSs,
    localSigs: Array<SerializableLocalSig>,
    partiesIndex: Array<number>,
    r: SerializablePoint,
  ): SerializableSignature;
  /** Verify signature */
  export function verifySignature(
    signature: SerializableSignature,
    message: Array<number>,
    publicKey: SerializablePoint,
  ): boolean;
}
